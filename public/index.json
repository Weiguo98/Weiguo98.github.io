


[{"content":"","date":"25 August 2025","externalUrl":null,"permalink":"/blog/","section":"Blogs","summary":"","title":"Blogs","type":"blog"},{"content":"","date":"25 August 2025","externalUrl":null,"permalink":"/tags/qnx/","section":"Tags","summary":"","title":"QNX","type":"tags"},{"content":" What is security policy? # Official documents: https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.security.system/topic/manual/security_policies.html\nIt basically is a file that in a system level set processes which operations it is permitted to do.\nHow is it used? # First, a secpol.txt can be get it from secpolgenerate or simply from any product itself.\nFirst, compile an executable called secpol.bin using secpolcompile. https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/s/secpolcompile.html\nThen, put it in /proc/boot. In some environment, you may not have access to modify the /proc/boot folder. Instead, we can create a link to it.\nln -sP /root/secpol.bin /proc/boot/secpol.bin\nFinally, run secpolpush. The security policy is pushed to the kernel, and it works immediately.\nThis means, now, if you would like to start any process, you need to assign a security policy to it, otherwise it will use init_t as the default security policy type.\nObservability # Use secpolmonitor to monitor security events:\nRun it to show uses of abilities and path space changes (detailed command documentation):\nsecpolmonitor -aps\nExample output:\ninfo: usr/sbin/sshd (pid:3325972) type init_t uses ability CHROOT as root info: proc/boot/example_app (pid:1) type default uses ability KEYDATA as root info: usr/sbin/sshd (pid:3325972) type init_t uses ability SETTYPEID(140) (ssh_privsep_t) as root info: usr/sbin/sshd (pid:3325972) type ssh_privsep_t uses ability SETGID(6) as root info: usr/sbin/sshd (pid:3325972) type ssh_privsep_t uses ability SETUID(15) as root Basic syntax explanation:\n# Type means new type definition type ssh_privsep_t; # Allow specific secpol type to have different abilities. This part means ssh_privsep_t can setuid and setgid. allow ssh_privsep_t self:ability { setuid:0x0-0xFFFFFFFF setgid:0x1-0xFFFFFFFF }; # Abilities can be separated to make them easier to manage, or you can keep them together. allow init_t self:ability { network/privport chroot } # This means init_t can have ability iofunc/exec as non-root user. allow init_t self:ability{ nonroot iofunc/exec }; More detailed explain: https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.security.system/topic/manual/secpol_language.html\nTroubleshoot # Secpolcompile failure\nSometimes, we will run into secpolcompile failure, for example:\nerror: type \u0026#39;sshd_t\u0026#39; cannot be granted ability \u0026#39;settypeid:ssh_privsep_t\u0026#39; as it would gain abilities: setuid: range setgid: range In this case, the error means that there are conflicts in abilities between sshd_t and ssh_privsep_t. Double check the abilities in both contexts, and make sure they have the same range of setuid and setgid. Be careful when you try to modify the abilities.\nOperation is not permitted\non: Operation not permitted (/usr/bin/example_app). It means on cannot start the process because the security type lacks some needed abilities to spawn the process. You can first check the secpolmonitor.log\nSecpolmonitor log # This is the common format for secpolmonitor.log. You can see there is an error saying that init_t lacks the iofunc/exec ability when running as non-root. Simply put iofunc/exec ability into init_t in the secpol.txt file, then recompile and push the policy. It should work.\ninfo: usr/bin/example_app (pid:xxxx) type init_t uses ability MAP_FIXED(337416937472 - 337416992071) as non-root info: usr/bin/example_app (pid:xxxx) type init_t uses ability MAP_FIXED(337417058792 - 337417060415) as non-root info: usr/bin/example_app (pid:xxxx) type init_t uses ability MAP_FIXED(337417056256 - 337417060351) as non-root error: usr/bin/example_app (pid:xxxx) type init_t lacks ability iofunc/exec as non-root info: usr/bin/example_app (pid:xxxx) type init_t uses ability PROT_EXEC(146050510848 - 146050768735) as non-root Pidin info # We can also check the process info via: pidin -F \u0026quot;%a %N %_\u0026quot;. In the output, we can clearly see if the process is started with correct security type.\n","date":"25 August 2025","externalUrl":null,"permalink":"/blog/qnx-secpol/qnx-secpol/","section":"Blogs","summary":"\u003ch2 class=\"relative group\"\u003eWhat is security policy? \n    \u003cdiv id=\"what-is-security-policy\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#what-is-security-policy\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eOfficial documents: \u003ca\n  href=\"https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.security.system/topic/manual/security_policies.html\"\n    target=\"_blank\"\n  \u003ehttps://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.security.system/topic/manual/security_policies.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIt basically is a file that in a system level set processes which operations it is permitted to do.\u003c/p\u003e","title":"Security Policy in QNX","type":"blog"},{"content":"","date":"25 August 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"25 August 2025","externalUrl":null,"permalink":"/","section":"Wei's Home","summary":"","title":"Wei's Home","type":"page"},{"content":"","date":"2024-09-01","externalUrl":null,"permalink":"/zh-cn/tags/daily/","section":"Tags","summary":"","title":"Daily","type":"tags"},{"content":"对于很多其他地方的人来说，欧洲旅行都是很令人向往的。但是周游欧洲所有国家，因为时间和金钱的原因，可能是很不现实的。 作为欧洲留子，在这里基于自己的旅游经验，给大家做一点推荐.\n第一梯队 # 匈牙利/捷克 # 推荐理由：物价相对较低，城市非常具有刻板印象中的欧洲风情，博物馆、皇宫、教堂都非常的漂亮。\n这两个国家地处中欧，整体消费水平是比较低的，相比于高物价的北欧/瑞士，同时又考虑到安全（包括难民/小偷等）问题，这两个国家的安全相对于法国/西班牙/意大利等都要好上很多。并且，布达佩斯作为之前奥匈帝国的中心之一，布拉格又是神圣罗马的首都，整体的欧洲风情是非常足的，给人感觉就是小时候会从书里/电视里看到的欧洲的样子，比如非常非常富丽堂皇的大教堂，欧式经典的建筑/老城，以及陈列十分丰富的博物馆。 相比较而言的话，瑞士/北欧都更倾向于自然风景一点，比如我在北欧从来没看见过里面贴画都是金子的教堂 :P.\n饮食方面的话，这两个国家都有很经典的牛肉汤+馒头吃，我觉得还是比较符合亚洲人的口味。并且布达佩斯还有经典的烧烤的一条街，都是华人开的店，可以说是想家了可以直接钻进去吃个昏天黑地。\n第二梯队 # 挪威/瑞士 # 如果你问我好不好看的话，我会说好看真的太好看了。但是你问我贵不贵的话，我只能说真的贵，贵的想死。如果说其他地方的话，我每天的预算大概在1200rmb包含食宿各种门票（不包含机票，酒店标准是普通非青旅），但是挪威和瑞士就要double才行，如果玩的地方比较多，甚至这个预算都打不住。\n这两个中，瑞士比较出名的主要是山景，各个角度的阿尔比斯山+内陆的湖泊，给人感觉像在windows壁纸里，只在山坡上漫步就会觉得幸福。挪威则是冰川/峡湾，是非常非常壮观的感觉，只能说很贵，也真的很值，而且欧洲其实旅游的人比较少，至少比国内很多景点人少很多，非常容易照出很漂亮很漂亮的照片。不过考虑到交通的便捷性，可能瑞士会相对来说舒服一点，虽然奥斯陆也有来回北京的航班，但是总体上瑞士在中欧，后面去其他的国家也比较方便，挪威的话，除非是继续去瑞典德国，不然2小时+的飞机肯定是没跑了。\n但是这两个国家的饮食，可以说是难吃的想死，至少对我来说，那么贵又那么难吃，真的不知道当地人是怎么活下来的。那奶酪火锅有幸尝了一次，太难吃了，都不如去超市买俩法棍在酒店吃。\n另外就是这两个国家也有比较多的小众景点，如果在小红书上进行搜索的话。不过其实我不是太建议去小众景点，一是多半开发程度受限，除非是对自己的语言能力等比较有信心，或者是已经来过几次欧洲轻车熟路，不然第一次来的话，还是很容易出现一些问题。另一个就是多半交通也不方便，本来国内来欧洲就要飞很久了，在倒火车/大巴，人都要没一半了。不过如果顺路的话，不妨一试。\n第三梯队 # 西班牙/意大利 # 这两个都是老牌旅游国家了，整体上肯定是没有问题，但是西班牙是小偷多，意大利是南部有黑手党，还是要注意安全。虽然说我去了都没什么事儿，但也有可能是因为我身上都是hm的旧衣服，小偷不愿意多看我一眼\u0026hellip;\n这两个国家除了一些知名景点，斗兽场/皇宫etc之外，就是感受风土人情啦，不得不说，南欧人还是有一手，我为数不多的几次旅游小费基本都给在南欧的餐馆了.. 具体去哪个城市，可以在小红书上搜索，我目前没踩过什么雷，都还可以。不过这两个国家也有一个问题就是，南欧人真的很随意，所以公交/火车晚点/取消都是家常便饭，计划的时候可以计划的不用那么详细，因为多半会计划赶不上变化快。所以也尽量不要在这两个国家特种兵，很容易特到最后，赶不上晚班车回家。\n法国 # 没去过，但是实在是太经典了，还是写上。不过法国的安全问题是目前最严重的（主要是巴黎，其他城市没太大问题），体感要远超其他国家了，我周围留子也是吐槽法国的最多，基本上都是去了一次，以后不会再去，因为实在是街道什么不太干净。\n剩下的国家，我认为就是比较普通，不值得单独为这个国家安排行程，但是路过的话可以去，比如荷兰/比利时/德国/奥地利etc，路过随便转两圈打个卡就可以了，没什么特别值得看的。包括红灯区什么的也是有点噱头大于实质了。\n航班的话，所有航班我都听过吐槽，各有各的槽点，就还是哪便宜哪儿买。至于网上的长途飞行神器之类的，我觉得都不太需要，包括拖鞋，除非你真的很爱水肿，做长时间高铁都会水肿的那种。我经常来回u型枕都没带，睡的也挺香的，腿也不麻。离线的小说/电视剧下好，充电宝/耳机充好电，就万事俱备了。希望大家来欧洲玩的开心，路过哥德堡可以找我吃饭 :P.\n","date":"2024-09-01","externalUrl":null,"permalink":"/zh-cn/blog/euro-tourist/euro-tourist/","section":"Blogs","summary":"\u003cp\u003e对于很多其他地方的人来说，欧洲旅行都是很令人向往的。但是周游欧洲所有国家，因为时间和金钱的原因，可能是很不现实的。\n作为欧洲留子，在这里基于自己的旅游经验，给大家做一点推荐.\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003e第一梯队 \n    \u003cdiv id=\"第一梯队\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e7%ac%ac%e4%b8%80%e6%a2%af%e9%98%9f\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\u003ch3 class=\"relative group\"\u003e匈牙利/捷克 \n    \u003cdiv id=\"匈牙利捷克\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%8c%88%e7%89%99%e5%88%a9%e6%8d%b7%e5%85%8b\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e推荐理由：物价相对较低，城市非常具有刻板印象中的欧洲风情，博物馆、皇宫、教堂都非常的漂亮。\u003c/p\u003e","title":"欧洲旅游经验分享","type":"blog"},{"content":"","date":"14 August 2024","externalUrl":null,"permalink":"/tags/ansible/","section":"Tags","summary":"","title":"Ansible","type":"tags"},{"content":"Handling errors during environment configuration with Ansible is crucial. While ignore_errors and fails_when keywords exist, they only apply to specific tasks, not to roles or entire playbooks.\nProblem Description # ignore_errors=true is ineffective in Ansible roles, only working within sessions. This requires repeatedly adding this option in test and subsequent tasks to ensure the next test runs even if the previous one fails. How can we avoid overusing ignore_errors and skip tests if pre-tasks fail?\nSolution # Refactor test cases using block, rescue, always, and clear_host_errors.\nExample:\n- block: - name: Pre tasks command: /bin/false - name: Test tasks command: /bin/false register: result rescue: - name: Record error ansible.builtin.debug: var: result always: - name: Post tasks command: echo \u0026#34;post tasks\u0026#34; - name: Clear host errors meta: clear_host_errors Detailed Explanation # Using ignore_errors:\nIn Ansible, if a task fails, Ansible will stop executing tasks on that host by default. However, you can use ignore_errors to ignore errors and continue execution. For example:\n- name: Attempt to Execute a Command command: /some/nonexistent/command ignore_errors: true # This task will fail, but the playbook will continue. Using block, rescue, and always\nBy breaking down each role\u0026rsquo;s tasks into multiple parts and using the block, rescue, and always keywords, more granular error handling can be achieved. As seen in the example above, if the pre task fails, the test task will not be executed because they are in the same block. The failure of an Ansible task will trigger the execution of the rescue block, where we can log errors. In the example, debug is used, but you can also write to a verdict/any file so that we can judge the overall test results in the end. Regardless of the execution status of the tasks in the block, the post task will always be executed. In the post task, you can add tasks such as collecting logs. Even if it fails, the tasks in always will still be executed. Finally, by using clear_host_error, the error is removed, so Ansible will not stop executing tasks on that host, and the next test block will still be executed.\nThis structure can build multiple tests in a playbook without affecting each other, which can reduce the number of VMs that need to be started at the same time to a certain extent.\nReferences # Ansible Error Handling ","date":"14 August 2024","externalUrl":null,"permalink":"/blog/ansible-ignore-errors/ansible-ignore-errors/","section":"Blogs","summary":"\u003cp\u003eHandling errors during environment configuration with Ansible is crucial. While ignore_errors and fails_when keywords exist, they only apply to specific tasks, not to roles or entire playbooks.\u003c/p\u003e\n\n\u003ch3 class=\"relative group\"\u003eProblem Description \n    \u003cdiv id=\"problem-description\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#problem-description\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eignore_errors=true\u003c/code\u003e is ineffective in Ansible roles, only working within sessions. This requires repeatedly adding this option in test and subsequent tasks to ensure the next test runs even if the previous one fails. How can we avoid overusing ignore_errors and skip tests if pre-tasks fail?\u003c/p\u003e","title":"Ansible complex set up error handling","type":"blog"},{"content":" When we have little data need to pass from helm chart to service, it quit easy to use the container.env part in the deployment.yaml. So that we could just os.getEnv() in the code, we got the value we want.\nBut what if we have a lot of values to pass, it is a mess to add them all in the helm chart. Then, we could use config map here. Personally, I prefer to use the JSON format, because it is easy to un-marshal to struct, and we can get easy access to all the values.\nHere are the exact steps to pass data through config map:\nSet up a config map with json format data.\napiVersion: \u0026#34;v1\u0026#34; kind: \u0026#34;ConfigMap\u0026#34; metadata: name: json-configmap data: config.json: | { \u0026#34;key1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;value2\u0026#34; } Create a volume in the pod and mount it to the container we want.\napiVersion: \u0026#34;apps/v1\u0026#34; kind: \u0026#34;Deployment\u0026#34; metadata: name: \u0026#34;test-service\u0026#34; spec: - template: metadata: volumes: - name: \u0026#34;json-config-volume\u0026#34; configMap: // make sure the name equals to the name in configmap metadata.name name: \u0026#34;json-configmap\u0026#34; containers: - name: \u0026#34;container-first\u0026#34; volumeMounts: - name: \u0026#34;config-volume\u0026#34; mountPath: \u0026#34;/etc/config\u0026#34; // not necessary, you can hardcoded in the code base, put it here just make sure // if anyday we changed the mountpath, make sure change the env as well. env: - name: \u0026#34;CONFIG_FILE\u0026#34; value: \u0026#34;/etc/config/config.json\u0026#34; In the code base, we can through os.getEnv() get easy access to the JSON file and do the un-marshal to it.\n// Based on the json format type JsonConfig struct{ key1 string key2 string } func getJsonConfig() error{ filePath, ok := os.LookupEnv(\u0026#34;CONFIG_FILE\u0026#34;) if !ok { return errors.New(\u0026#34;failed to get file path\u0026#34;) } config, err := os.Open(filePath) if err != nil { return errors.Wrap(err, \u0026#34;failed to open file\u0026#34;) } defer config.Close() byteValue, err := io.ReadAll(config) if err != nil { return errors.Wrap(err, \u0026#34;failed to read file\u0026#34;) } jsonConfig := \u0026amp;JsonConfig{} if err = json.Unmarshal(byteValue, jsonConfig); err != nil { return errors.Wrap(err, \u0026#34;failed to unmarshal file\u0026#34;) } return nil } ","date":"25 May 2023","externalUrl":null,"permalink":"/blog/pass-data-in-json/pass-data-in-json/","section":"Blogs","summary":"\u003c!-- markdownlint-disable MD010 --\u003e\n\u003cp\u003eWhen we have little data need to pass from helm chart to service, it quit easy to use the \u003ccode\u003econtainer.env\u003c/code\u003e part in the \u003ccode\u003edeployment.yaml\u003c/code\u003e. So that we could just \u003ccode\u003eos.getEnv()\u003c/code\u003e in the code, we got the value we want.\u003c/p\u003e","title":"How to pass data in JSON format in config map to the microservice","type":"blog"},{"content":"","date":"25 May 2023","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"Kubernetes","type":"tags"},{"content":" Readiness and Liveness probe Configure Liveness, Readiness and Startup Probes | Kubernetes The kubelet uses liveness probes to know when to restart a container. For example, liveness probes could catch a deadlock, where an application is running, but unable to make progress. Restarting a container in such a state can help to make the application more available despite bugs. The kubelet uses readiness probes to know when a container is ready to start accepting traffic. A Pod is considered ready when all of its containers are ready. One use of this signal is to control which Pods are used as backends for Services. When a Pod is not ready, it is removed from Service load balancers. The readiness check will continuously run in the pod lifecycle. As long as Liveness Probe passed, the pod status changed to running. If you want to connect to a pod when it is ready for traffic, it is better to check the ready keywords.\nPod lifecycle Pod Lifecycle | Kubernetes Value Description Pending The Pod has been accepted by the Kubernetes cluster, but one or more of the containers has not been set up and made ready to run. This includes time a Pod spends waiting to be scheduled as well as the time spent downloading container images over the network. Running The Pod has been bound to a node, and all of the containers have been created. At least one container is still running, or is in the process of starting or restarting. Succeeded All containers in the Pod have terminated in success, and will not be restarted. Failed All containers in the Pod have terminated, and at least one container has terminated in failure. That is, the container either exited with non-zero status or was terminated by the system. Unknown For some reason the state of the Pod could not be obtained. This phase typically occurs due to an error in communicating with the node where the Pod should be running. When a Pod is being deleted, it is shown as Terminating by some kubectl commands. This Terminating status is not one of the Pod phases. A Pod is granted a term to terminate gracefully, which defaults to 30 seconds. You can use the flag --force to terminate a Pod by force.\n","date":"25 January 2023","externalUrl":null,"permalink":"/blog/kubernetes-pods-lifecycle/","section":"Blogs","summary":"\u003cul\u003e\n\u003cli\u003eReadiness and Liveness probe\n\u003ca\n  href=\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#before-you-begin\"\n    target=\"_blank\"\n  \u003eConfigure Liveness, Readiness and Startup Probes | Kubernetes\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003ca\n  href=\"https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/\"\n    target=\"_blank\"\n  \u003ekubelet\u003c/a\u003e uses liveness probes to know when to restart a container. For example, liveness probes could catch a deadlock, where an application is running, but unable to make progress. Restarting a container in such a state can help to make the application more available despite bugs.\u003c/li\u003e\n\u003cli\u003eThe kubelet uses readiness probes to know when a container is ready to start accepting traffic. A Pod is considered ready when all of its containers are ready. One use of this signal is to control which Pods are used as backends for Services. When a Pod is not ready, it is removed from Service load balancers.\u003c/li\u003e\n\u003cli\u003eThe readiness check will continuously run in the pod lifecycle.\n\u003cblockquote\u003e\n\u003cp\u003eAs long as Liveness Probe passed, the pod status changed to \u003ccode\u003erunning\u003c/code\u003e. If you want to connect to a pod when it is ready for traffic, it is better to check the \u003ccode\u003eready\u003c/code\u003e keywords.\u003c/p\u003e","title":"Kubernetes probes and pod lifecycle","type":"blog"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]